---
navhome: /docs/
next: true
title: 1.2
---

### 1.2 - Let's send ourself a message using `:talk`

You've probably already used the `:talk` UI for our distributed chat, either from the command line, the browser, or both. But really, the `:talk` API is a general-purpose piece of infrastructure for messaging and notifications that `:talk`-the-UI just happens to use. Meaning, we can actually use the `:talk` protocol as a basic message bus and data store to power any kind of UI.

Before we checkout to the next branch, you'll need to officially Log In to your ship through the web to gain full authentication privileges. That way we can send `:talk` messages from our own code smoothly. And while we're at it, we can take a peek at `:talk` the existing web app to better understand the `:talk` API it's built on top of.

Head to your `:talk` web UI being served at `https://localhost:8443/~~/talk`. The `/~~/` in the URL will redirect you to a Log In page asking for a password, which you can retrieve from the `+code` `:dojo` command and paste into the Log In box. Something like:

```
> +code
ritrys-divtec-fidtyr-tocnym
```

If you successfully logged in, your `:talk` web app should load up
automatically:

> * XX ![screenshot of talk the web ui](https://placeimg.com/640/480/arch/grayscale)

The `:talk` protocol is organized around _posts_ and _stations_; posts are typed, authenticated, encrypted messages, and stations are configurable feeds to send and read posts. This is all you really need to know for this tutorial, but more details on the protocol can be found [here](https://urbit.org/docs/using/messaging).

Let's try playing around with this here in the current `:talk` web UI, and then let's see if we can replicate similar functionality in our own UI with the frontend tools already in your ship.

Since we're on comets, we can send ourselves a direct `:talk` post at our *~ship/porch* station by inputting our _audience_, post text and sending by hitting the Enter key:

* XX ![GIF close-up of typing, sending and receiving message in web UI and `:dojo`.](https://placeimg.com/640/480/arch/grayscale)

You may find the Console and Networking activity interesting, but we'll implement the same functionality ourselves in a minute.

There are different kinds of `:talk` stations. Your porch is a `%mailbox`; like an inbox, it's publicly writeable, but only you can decrypt its posts and read from it. Of course, our porch isn't reliant on any server other than your personal ship. So only you in fact have access to these particular messages. Another ship who tries to subscribe to your porch mailbox will see an error.

Let's see if we if we can code our own simple way to send ourselves a private porch message by modifying our code from the last section.

`checkout` to the `1.2` branch:

```
$ git checkout 1.2
```

Keeping the `/~~/` in our URL this time to ensure you're authenticated (if you're logged in, it won't redirect you), let's load up our `http://localhost:8443/~~/tutorial.html` page.

Now, go ahead and send yourself a `:talk` message!

* XX ![GIF 'Send yourself a `:talk` message, ~ship!' + textbox and submit](https://placeimg.com/640/480/arch/grayscale)

Cool, this worked. With our dev tools again, let's look at the JSON payload we sent this time:

```
{
  "oryx": "falwep-docder-marmev-norpur--sabsem-botlex-hodnup-dirsup",
  "appl": "talk",
  "mark": "talk-command",
  "ship": "lannyx-parlyn-picrus-latruc--tacnel-wactec-livput-lishes",
  "wire": "/",
  "xyro": {
    "publish": [
      {
        "serial": "0v7.985re.6urnn.8g80s.7mn5o.2njuo.0e4mk",
        "audience": {
          "~lannyx-parlyn-picrus-latruc--tacnel-wactec-livput-lishes/porch": {
            "envelope": {
              "visible": true,
              "sender": null
            },
            "delivery": "pending"
          }
        },
        "statement": {
          "bouquet": [],
          "speech": {
            "lin": {
              "txt": "test from our own code!",
              "say": true
            }
          },
          "date": 1489430871493              * XX update to publish day date
        }
      }
    ]
  }
}
```

This may look a bit more intimidating, but actually our payload is pretty much the same as our last 'hi'. We just have a different data payload -- a typed `:talk` post:
- You have a new CSRF `oryx` for the session.
- Your `appl` is now `"talk"`.
- Your `mark` is now a `"talk-command"`.
- Your `ship` and `wire` are the same.
- And then you have this way-different `xyro` data value: a typed
  `:talk` message.
* XX you/your vs. we/our

So, let's look under the hood of our code:

Your `tutorial.html` looks like this:

```
<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <title>Urbit from the Web</title>

    <script src="/~~/~/at/=home=/web/lib/js/urb.js"></script>
    <script src="/~~/=home=/web/tutorial/tutorial.js"></script>
  </head>

  <body>
    <div>
      <h1 id="shipDisplay"></h1>
    </div>
    <br />

    <div>
      <input id="postBox" type="text" size="80" value="">Text
      <br />
      <button id="postButton" onclick='sendPost();'>Post</button>
    </div>

    <script>
      document.getElementById('shipDisplay').innerHTML = '~' + window.urb.user;
    </script>
  </body>
</html>
```

and here's your `main.js`:

```
// util

function mainStation(user) {
  switch (user.length) {
    case 3:
      return 'court';
    case 6:
      return 'floor';
    default:
      return 'porch';
  }
}

function uuid32() {                                     // generate unique serial number
  var i;
  var digitGroup;
  var serial = '0v' + Math.ceil(Math.random() * 8) + '.';
  for (i = 0; i <= 5; ++i) {
    digitGroup = Math.ceil(Math.random() * 10000000).toString(32);
    digitGroup = ('00000' + digitGroup).substr(-5, 5);
    serial += digitGroup + '.';
  }
  return serial.slice(0, -1);
}

// main

function sendPost() {
  var audience;
  var post;
  var speech;
  var station;
  var text;
  var thought;

  document.getElementById('postButton').disabled = true;

  text = document.getElementById('postBox').value;
  station = '~' + window.urb.user + '/' + mainStation(window.urb.user);

  audience = {};
  audience[station] = {
    envelope: {
      visible: true,
      sender: null
    },
    delivery: 'pending'
  };

  speech = {
    lin: {
      txt: text,
      say: true
    }
  };

  thought = {
    serial: uuid32(),
    audience: audience,
    statement: {
      bouquet: [],
      speech: speech,
      date: Date.now()
    }
  };

  post = {};
  post.publish = [thought];

  return window.urb.send(
    post,                                               // data
    {                                                   // params
      appl: 'talk',
      mark: 'talk-command',
      ship: window.urb.user
    },
    function sentMessage(error, response) {             // callback
      if (error || !response.data || response.fail) {
        console.warn('`urb.send` to ~' + window.urb.user + ' the data payload:');
        console.warn(post);
        console.warn('failed. Error:');
        console.warn(error);
        console.warn(response);
        return;
      }
      console.log('`urb.send` to ~' + window.urb.user + ' the data payload:');
      console.log(post);
      console.log('succeeded! Response:');
      console.log(response.data);
      document.getElementById('postButton').disabled = false;
    });
}

window.module = window.module || {};
module.exports = {
  sendPost: sendPost
};
```

This code actually isn't super interesting. Our `urb.send` call is basically the same as our last 'Hi' example, as you could probably infer from the JSON payload sent above. The only different things really are the helper functions that collectively we use to format a valid `:talk` post.

A `:talk` post is pretty simple. It needs:
- a sender -- your ship in this case;
- an audience-- your porch here;
- a serial number -- a 32-character [`UUID`](https://en.wikipedia.org/wiki/Universally_unique_identifier);
- a date -- whenever `Date.now()` was at the time the message was sent;
- and the post text itself.

Once we construct our valid `:talk` message from our post box input, we send this object as the `xyro` or `data` value of our `urb.send` call, along with the `"talk"` `appl` and `"talk-command"` mark. %eyre then reads this POST request, parses its contents, and passes the post data to your ship's `:talk` backend.

All of the different urb.js requests are [here](http://urbit.org/docs/using/web/#-urb-js) in our Docs. Let's delve into a few more requests in the next sections, though, as they relate to using the `:talk` protocol for our own apps.
