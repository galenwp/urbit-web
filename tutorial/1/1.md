---
navhome: /docs/
next: true
title: 1.1
---

### 1.1 - Time to talk to your ship.

Let's start with a hard-coded way to say hi to our ship over HTTP.

Checkout to the `1.1` branch for this section:

```
$ git checkout 1.1
```

In your `:dojo`, your ship should have recognized changes to your two files:

```
: /~lannyx-parlyn-picrus-latruc--tacnel-wactec-livput-lishes/home/3/web/tutorial/html
: /~lannyx-parlyn-picrus-latruc--tacnel-wactec-livput-lishes/home/3/web/tutorial/tutorial/js
>
```

The case of your home desk should be incremented as a result of the change.

Reload `localhost`, and with your dev tools open again and your `:dojo` in sight, click the button!

* XX ![says hi](https://placeimg.com/640/480/arch/grayscale)

Let's quickly go over what just happened.

Somehow from clicking that button, you were able to talk to your ship.

We did this using the simple HTTP API in our small [`urb.js`](https://github.com/urbit/arvo/blob/maint-20160818/web/lib/js/urb.js) library, which is included in all booted ships' web directories by default. We sourced urb.js in our .html file via a `<script src>` tag in our `<head>`.

Here's the new code:

```
...

  <head>

    ...

    <script src="/~/at/=home=/web/lib/js/urb.js"></script>
    <script src="/=home=/web/tutorial/tutorial.js"></script>

  </head>

  <body>

    <div>
      <button id="hiButton" onclick='sayHi();'>Say hi to your ship!</button>
    </div>
    <br />

    <div id="response">
    </div>
    <br />

    <div id="shipHi">
    </div>

  </body>
</html>
```

```
function sayHi() {
  var data = 'hi. :)';

  document.getElementById('hiButton').disabled = true;

  return window.urb.send(
    data,                                               // data
    {                                                   // params
      appl: 'hood',
      mark: 'helm-hi',
      ship: window.urb.user
    },
    function sentMessage(error, response) {             // callback
      if (error || !response.data || response.fail) {
        console.warn('`urb.send` to ~' + window.urb.user + ' the data payload:');
        console.warn(data);
        console.warn('failed. Error:');
        console.warn(error);
        console.warn(response);
        return;
      }
      console.log('`urb.send` to ~' + window.urb.user + ' the data payload:');
      console.log(data);
      console.log('succeeded! Response:');
      console.log(response.data);
      document.getElementById('response').innerHTML = '<code>' + JSON.stringify(response.data) + '</code>';
      document.getElementById('shipHi').innerHTML = '<code>~' + window.urb.user + '</code> says hi back!';
      document.getElementById('hiButton').disabled = false;
    });
}

window.module = window.module || {};
module.exports = {
  sayHi: sayHi
};
```

When we load files from our ship, we load them from [`%clay`](https://urbit.org/docs/using/filesystem), Urbit's typed, global, referentially transparent namespace that serves as a revision-controlled filesystem. A full `%clay` path for a file is `~ship/desk/case/path/to/file`,  since it's possible to use files on other ships as if they were local (almost), and since everything is version-controlled.

Most of the time, we'll just be wanting to access our ship's latest case files of our current working desk. We do that with the syntax `/=home=/` here. When you visit any Urbit URL, if a %clay path isn't specified, it defaults to the lastest case files of the desk being `|served`, which in this case is `home`.

To show %clay works though, try viewing the last example without checking out by changing your URL to: `http://localhost:8443/=home/2/tutorial.html`

By appending the `/~/at/` before the file path in that `<script>` tag, we told our ship to inject authentication and user JSON data to the top of our urb.js file under the `window.urb` object.

Pretty-printed:

```
var _urb = {
  "oryx": "bardys-ridmes-salser-napreg--watwer-ribmyn-midsul-digber",
  "user": "lannyx-parlyn-picrus-latruc--tacnel-wactec-livput-lishes",
  "sein": "zod",
  "ixor": "morret-taspeg-ritlug-fortug",
  "ship": "lannyx-parlyn-picrus-latruc--tacnel-wactec-livput-lishes",
  "auth": [
    "lannyx-parlyn-picrus-latruc--tacnel-wactec-livput-lishes"
  ]
};
```

- An `oryx` is just a [CSRF token](https://en.wikipedia.org/wiki/Cross-site_request_forgery) for authentication.
- `ixor` is a hash of this CSRF token, also for authentication.
- `user`, `ship` and `auth` are all additionally there for authentication; if one of the three doesn't match, your ship will know that either you're not logged in, or that something is being fabricated.
- And lastly, `sein` is the parent of the current ship. While a planet's parent is a star, a comet's parent is a galaxy. On the current maintenance network, all comets including yours will have the galaxy parent `~zod`, or galaxy `0`.

`urb.js` has several wrapper functions over different [XMLHttpRequests](https://en.wikipedia.org/wiki/XMLHttpRequest) that can send different requests to your ship's web server, `%eyre`.

For this simple example, we called the `urb.send` function, which takes as arguments 1) a data value; 2) an object of parameters further specifying the message being sent; and 3) a callback function to execute upon a successful or failed request. `urb.send` then takes the data and params arguments, stringifies them, and sends them as a JSON payload to your ship's backend. You ship was then able to parse this JSON and send the right contents to the right Hoon program for execution.

Here's the pretty-printed JSON payload `urb.send` delivered:

```
{
  "oryx": "modtuc-diffus-ropdef-novluc--satlev-tomrut-lodres-digweg",
  "ship": "lannyx-parlyn-picrus-latruc--tacnel-wactec-livput-lishes",
  "appl": "hood",
  "mark": "helm-hi",
  "wire": "/"
  "xyro": "hi. :)",
}
```

- We're already familiar with what our `oryx` is: an authenticated CSRF token.
- The default `ship` value is the same one in the `window.urb` object described above.
- The `params` that we specified we then placed in an object that contained two name-value pairs:
  1. Our `appl`, for 'application', was `"hood"`, your ship's system daemon.
  2. And and our `mark`, or message type (similar to a [MIME type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types)), was a `"helm-hi"`, which just told `hood` to run our simple _helm-hi_ Hoon program to take the data value sent and print it to the screen. Basically, just like a traditional 'Hello, world!'.
- The `wire` value specifies the path endpoint for the request. Urbit requests follow [Command-Query Separation](https://en.wikipedia.org/wiki/Command%E2%80%93query_separation) (CQS) principles, which we'll get to soon when dealing with subscription requests. But for this simple example, since we sent a basic default command, the wire sent was the default path, `"/"`, which just sets the endpoint to your ship generally. Notice that in the `urb.send` call itself in our tutorial.js, no wire was specified; so the default value came from `urb.js` (you can check out that code if you want to by loading up ~ship/home/web/lib/urb.js in your editor, or again looking [here](https://github.com/urbit/arvo/blob/maint-20160818/web/lib/js/urb.js)).
- And our data value, renamed `xyro`, was just the string, `"hi. :)"`.

Lastly, upon the successful request, our callback function simply  had us `console.log` the request response; our ship sent us an `{ok:true}`, meaning "everything is all good!". And we inserted this stringified object into the DOM along with a hard-coded string telling us our ship says hi back. Your code got your `ship` value from the `window.urb` object.

Another example will help make more sense of this. Let's try sending ourselves a `:talk` message.
